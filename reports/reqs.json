[
  {
    "reqline": ":white_check_mark: **DO** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation."
  },
  {
    "reqline": ":no_entry: **DO NOT** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation."
  },
  {
    "reqline": ":white_check_mark: **DO** use this URL pattern:"
  },
  {
    "reqline": ":white_check_mark: **DO** use kebab-casing (preferred) or camel-casing for URL path segments. If the segment refers to a JSON field, use camel casing.",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** return `414-URI Too Long` if a URL exceeds 2083 characters",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** treat service-defined URL path segments as case-sensitive. If the passed-in case doesn't match what the service expects, the request **MUST** fail with a `404-Not found` HTTP return code.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** ensure proper casing when returning a URL in an HTTP response header value or inside a JSON response body",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** restrict the characters in service-defined path segments to `0-9  A-Z  a-z  -  .  _  ~`, with `:` allowed only as described below to designate an action operation.",
    "linter": true,
    "rule": "az-path-convention"
  },
  {
    "reqline": ":white_check_mark: **DO** return URLs in response headers/bodies in a consistent form regardless of the URL used to reach the resource. Either always a UUID for `<tenant>` or always a single verified domain.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** ensure that _all_ HTTP methods are idempotent.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** adhere to the return codes in the following table when the method completes synchronously and is successful:",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** return status code `202-Accepted` and follow the guidance in [Long-Running Operations & Jobs](#long-running-operations--jobs) when a PUT, PATCH, POST, or DELETE method completes asynchronously."
  },
  {
    "reqline": ":white_check_mark: **DO** treat method names as case sensitive and should always be in uppercase",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** return the state of the resource after a PUT, PATCH, POST, or GET operation with a `200-OK` or `201-Created`.",
    "linter": true,
    "rule": "az-consistent-response-body"
  },
  {
    "reqline": ":white_check_mark: **DO** return a `204-No Content` without a resource/body for a DELETE operation (even if the URL identifies a resource that does not exist; do not return `404-Not Found`)",
    "linter": true,
    "rule": "az-delete-204-response"
  },
  {
    "reqline": ":white_check_mark: **DO** return a `403-Forbidden` when the user does not have access to the resource _unless_ this would leak information about the existence of the resource that should not be revealed for security/privacy reasons, in which case the response should be `404-Not Found`. [Rationale: a `403-Forbidden` is easier to debug for customers, but should not be used if even admitting the existence of things could potentially leak customer secrets.]",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** support caching and optimistic concurrency by honoring the the `If-Match`, `If-None-Match`, if-modified-since, and if-unmodified-since request headers and by returning the ETag and last-modified response headers",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** validate all query parameter and request header values and fail the operation with `400-Bad Request` if any value fails validation. Return an error response as described in the [Handling Errors](#Handling-errors) section indicating what is wrong so customer can diagnose the issue and fix it themselves.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** use the following table when translating strings:",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** support all headers shown in _italics_",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** specify headers using kebab-casing",
    "linter": true,
    "rule": "az-parameter-names-convention"
  },
  {
    "reqline": ":white_check_mark: **DO** compare request header names using case-insensitivity",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** compare request header values using case-sensitivity if the header name requires it",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** accept date values in headers in HTTP-Date format and return date values in headers in the IMF-fixdate format as defined in [RFC7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1), e.g. \"Sun, 06 Nov 1994 08:49:37 GMT\".",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** create an opaque value that uniquely identifies the request and return this value in the `x-ms-request-id` response header.",
    "liveTest": true
  },
  {
    "reqline": ":no_entry: **DO NOT** fail a request that contains an unrecognized header. Headers may be added by API gateways or middleware and this must be tolerated",
    "liveTest": true
  },
  {
    "reqline": ":no_entry: **DO NOT** use \"x-\" prefix for custom headers, unless the header already exists in production [[RFC 6648](https://datatracker.ietf.org/doc/html/rfc6648)].",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** focus heavily on clear & consistent naming"
  },
  {
    "reqline": ":white_check_mark: **DO** ensure your resource paths make sense"
  },
  {
    "reqline": ":white_check_mark: **DO** simplify operations with few required query parameters & JSON fields"
  },
  {
    "reqline": ":white_check_mark: **DO** establish clear contracts for string values"
  },
  {
    "reqline": ":white_check_mark: **DO** use proper response codes/bodies so customer can diagnose their own problems and fix them without contacting Azure support or the service team"
  },
  {
    "reqline": ":white_check_mark: **DO** use the same JSON schema for PUT request/response, PATCH response, GET response, and POST request/response on a given URL path. The PATCH request schema should contain all the same fields with no required fields. This allows one SDK type for input/output operations and enables the response to be passed back in a request.",
    "linter": true,
    "rule": "az-consistent-response-body"
  },
  {
    "reqline": ":white_check_mark: **DO** think about your resource's fields and how they are used:"
  },
  {
    "reqline": ":white_check_mark: **DO** make fields simple and maintain a shallow hierarchy.",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** use camel case for all JSON field names. Do not upper-case acronyms; use camel case.",
    "linter": true,
    "rule": "az-property-names-convention"
  },
  {
    "reqline": ":white_check_mark: **DO** treat JSON field names with case-sensitivity.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** treat JSON field values with case-sensitivity. There may be some exceptions (e.g. GUIDs) but avoid if at all possible.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** use GET for resource retrieval and return JSON in the response body"
  },
  {
    "reqline": ":white_check_mark: **DO** create and update resources using PATCH [RFC5789] with JSON Merge Patch [(RFC7396)](https://datatracker.ietf.org/doc/html/rfc7396) request body.",
    "linter": true,
    "rule": "az-patch-content-type"
  },
  {
    "reqline": ":white_check_mark: **DO** use PUT with JSON for wholesale create/update operations. **NOTE:** If a v1 client PUTs a resource; any fields introduced in V2+ should be reset to their default values (the equivalent to DELETE followed by PUT).",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** use DELETE to remove a resource."
  },
  {
    "reqline": ":white_check_mark: **DO** fail an operation with `400-Bad Request` if the request is improperly-formed or if any JSON field name or value is not fully understood by the specific version of the service. Return an error response as described in [Handling errors](#Handling-errors) indicating what is wrong so customer can diagnose the issue and fix it themselves.",
    "liveTest": true
  },
  {
    "reqline": ":no_entry: **DO NOT** return secret fields via GET. For example, do not return `administratorPassword` in JSON."
  },
  {
    "reqline": ":no_entry: **DO NOT** add fields to the JSON if the value is easily computable from other fields to avoid bloating the body."
  },
  {
    "reqline": ":white_check_mark: **DO** follow the processing below to create/update/replace a resource:"
  },
  {
    "reqline": ":white_check_mark: **DO** return an `x-ms-error-code` response header with a string error code indicating what went wrong.",
    "linter": true,
    "rule": "az-error-response"
  },
  {
    "reqline": ":white_check_mark: **DO** carefully craft unique `x-ms-error-code` string values for errors that are recoverable at runtime.  Reuse common error codes for usage errors that are not recoverable."
  },
  {
    "reqline": ":white_check_mark: **DO** ensure that the top-level error's `code` value is identical to the `x-ms-error-code` header's value.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** document the service's error code strings; they are part of the API contract.",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** provide a response body with the following structure:",
    "linter": true,
    "rule": "az-error-response"
  },
  {
    "reqline": ":white_check_mark: **DO** use integers within the acceptable range of JSON number."
  },
  {
    "reqline": ":white_check_mark: **DO** establish a well-defined contract for the format of strings. For example, determine maximum length, legal characters, case-(in)sensitive comparisons, etc. Where possible, use standard formats, e.g. RFC3339 for date/time.",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** use strings formats that are well-known and easily parsable/formattable by many programming languages, e.g. RFC3339 for date/time.",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** ensure that information exchanged between your service and any client is \"round-trippable\" across multiple programming languages."
  },
  {
    "reqline": ":white_check_mark: **DO** use [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339) for date/time.",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** use [RFC4122](https://datatracker.ietf.org/doc/html/rfc4122) for UUIDs."
  },
  {
    "reqline": ":white_check_mark: **DO** document to customers that new values may appear in the future so that customers write their code today expecting these new values tomorrow."
  },
  {
    "reqline": ":no_entry: **DO NOT** remove values from your enumeration list as this breaks customer code."
  },
  {
    "reqline": ":white_check_mark: **DO** define a `kind` field indicating the kind of the resource and include any kind-specific fields in the body."
  },
  {
    "reqline": ":white_check_mark: **DO** use a POST operation for any action on a resource or collection.",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** support the Repeatability-Request-ID & Repeatability-First-Sent request headers if the action needs to be idempotent if retries occur."
  },
  {
    "reqline": ":white_check_mark: **DO** return a `200-OK` when the action completes synchronously and successfully."
  },
  {
    "reqline": ":no_entry: **DO NOT** use an action operation when the operation behavior could reasonably be defined as one of the standard REST Create, Read, Update, Delete, or List operations."
  },
  {
    "reqline": ":white_check_mark: **DO** structure the response to a list operation as an object with a top-level array field containing the set (or subset) of resources.",
    "linter": true,
    "rule": "az-pagination-response"
  },
  {
    "reqline": ":white_check_mark: **DO** include the _id_ field and _etag_ field (if supported) for each item as this allows the customer to modify the item in a future operation.",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** clearly document that resources may be skipped or duplicated across pages of a paginated collection unless the operation has made special provisions to prevent this (like taking a time-expiring snapshot of the collection)."
  },
  {
    "reqline": ":white_check_mark: **DO** return a `nextLink` field with an absolute URL that the client can GET in order to retrieve the next page of the collection.",
    "linter": true,
    "rule": "az-pagination-response"
  },
  {
    "reqline": ":no_entry: **DO NOT** return the `nextLink` field at all when returning the last page of the collection.",
    "liveTest": true
  },
  {
    "reqline": ":no_entry: **DO NOT** ever return a `nextLink` field with a value of null.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** return an error if the client specifies any parameter not supported by the service.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** treat these query parameter names as case-sensitive.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** apply `select` or `expand` options after applying all the query options in the table above."
  },
  {
    "reqline": ":white_check_mark: **DO** apply the query options to the collection in the order shown in the table above."
  },
  {
    "reqline": ":no_entry: **DO NOT** prefix any of these query parameter names with \"$\" (the convention in the [OData standard](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_QueryingCollections)).",
    "linter": true,
    "rule": "az-parameter-names-convention"
  },
  {
    "reqline": ":white_check_mark: **DO** omit all resources from the collection for which the `filter` expression evaluates to false or to null, or references properties that are unavailable due to permissions."
  },
  {
    "reqline": ":white_check_mark: **DO** respond with an error message as defined in the [Handling Errors](#handling-errors) section if a client includes an operator in a `filter` expression that is not supported by the operation.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** use the following operator precedence for supported operators when evaluating `filter` expressions. Operators are listed by category in order of precedence from highest to lowest. Operators in the same category have equal precedence and should be evaluated left to right:"
  },
  {
    "reqline": ":white_check_mark: **DO** sort the collection in ascending order on an expression if \"asc\" or \"desc\" is not specified.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** sort NULL values as \"less than\" non-NULL values.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** sort items by the result values of the first expression, and then sort items with the same value for the first expression by the result value of the second expression, and so on.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** use the inherent sort order for the type of the field. For example, date-time values should be sorted chronologically and not alphabetically.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** respond with an error message as defined in the [Handling Errors](#Handling-errors) section if the client requests sorting by a field that is not supported by the operation.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** use the same `filter`ing options and sort order for all pages of a paginated list operation response.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** define the `skip` parameter as an integer with a default and minimum value of 0.",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** define the `top` parameter as an integer with a minimum value of 1. If not specified, `top` has a default value of infinity.",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** return the collection's `top` number of resources (if available), starting from `skip`.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** define the `maxpagesize` parameter as an optional integer with a default value appropriate for the collection.",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** make clear in documentation of the `maxpagesize` parameter that the operation may choose to return fewer resources than the value specified."
  },
  {
    "reqline": ":white_check_mark: **DO** review any API changes with the Azure API Stewardship Board"
  },
  {
    "reqline": ":white_check_mark: **DO** use an `api-version` query parameter with a `YYYY-MM-DD` date value, with a `-preview` suffix for a preview service.",
    "linter": true,
    "rule": "az-version-policy"
  },
  {
    "reqline": ":white_check_mark: **DO** use a later date for each new preview version"
  },
  {
    "reqline": ":white_check_mark: **DO** use a later date for successive preview versions."
  },
  {
    "reqline": ":no_entry: **DO NOT** introduce any breaking changes into the service."
  },
  {
    "reqline": ":no_entry: **DO NOT** include a version number segment in any operation path.",
    "linter": true,
    "rule": "az-version-policy"
  },
  {
    "reqline": ":no_entry: **DO NOT** use the same date when transitioning from a preview API to a GA API. If the preview `api-version` is '2021-06-04-preview', the GA version of the API **must be** a date later than 2021-06-04"
  },
  {
    "reqline": ":no_entry: **DO NOT** keep a preview feature in preview for more than 1 year; it must go GA (or be removed) within 1 year after introduction."
  },
  {
    "reqline": ":white_check_mark: **DO**  support API version discovery, including"
  },
  {
    "reqline": ":white_check_mark: **DO** implement an operation as an LRO if the 99th percentile response time is greater than 1s."
  },
  {
    "reqline": ":white_check_mark: **DO** use the RELO pattern when the operation is on a resource that contains a \"status\" property that can be used to obtain the outcome of the operation."
  },
  {
    "reqline": ":white_check_mark: **DO** return a `200-OK` response, `201-Created` for create operations, from the request that initiates the operation.  The response body should contain a representation of the resource that clearly indicates that the operation has been accepted or started."
  },
  {
    "reqline": ":white_check_mark: **DO** support a get method on the resource that returns a representation of the resource including the status field that indicates when the operation has completed."
  },
  {
    "reqline": ":white_check_mark: **DO** define the \"status\" field of the resource as an enum with all the values it may contain including the \"terminal\" values \"Succeeded\", \"Failed\", and \"Canceled\". See [Enums & SDKs](#enums--sdks-client-libraries).",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** return a `202-Accepted` status code from the request that initiates an LRO with status monitor if the processing of the operation was successfully initiated."
  },
  {
    "reqline": ":white_check_mark: **DO** perform as much validation of the initial request as practical and return an error response immediately when appropriate (without starting the operation)."
  },
  {
    "reqline": ":white_check_mark: **DO** return the status monitor URL in the `Operation-Location` response header.",
    "linter": true,
    "rule": "az-lro-headers"
  },
  {
    "reqline": ":white_check_mark: **DO** support the `get` method on the status monitor endpoint that returns a `200-OK` response with a response body that contains the completion status of the operation with sufficient information to diagnose any potential failures."
  },
  {
    "reqline": ":white_check_mark: **DO** include a field in the status monitor resource named `status` indicating the operation's status. This field should be a string with well-defined values. Indicate the terminal state using \"Succeeded\", \"Failed\", or \"Canceled\".",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** include a field in the status monitor named `error` to contain error information -- minimally `code` and `message` fields -- when an operation fails.",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** retain the status monitor resource for some documented period of time (at least 24 hours) after the operation completes."
  },
  {
    "reqline": ":white_check_mark: **DO** include a `Retry-After` header in the response to the initiating request and requests to the operation-location URL. The value of this header should be an integer number of seconds to wait before making the next request to the operation-location URL.",
    "linter": true
  },
  {
    "reqline": ":no_entry: **DO NOT** return any data in the response body of a `202-Accepted` response.",
    "linter": true
  },
  {
    "reqline": ":white_check_mark: **DO** return **both** `Azure-AsyncOperation` and `Operation-Location` headers if your service previously returned `Azure-AsyncOperation`, even though they are redundant, so that existing clients will continue to operate."
  },
  {
    "reqline": ":white_check_mark: **DO** return the same value for **both** headers.",
    "liveTest": true
  },
  {
    "reqline": ":white_check_mark: **DO** look for **both** headers in client code, preferring the `Operation-Location` header."
  },
  {
    "reqline": ":white_check_mark: **DO** use Azure Bring Your Own Storage."
  },
  {
    "reqline": ":white_check_mark: **DO** use a blob prefix"
  },
  {
    "reqline": ":no_entry: **DO NOT** require a fresh container per operation"
  },
  {
    "reqline": ":white_check_mark: **DO** Add RBAC roles for every service operation that requires accessing Storage scoped to the exact permissions."
  },
  {
    "reqline": ":white_check_mark: **DO** Ensure that RBAC roles are backward compatible, and specifically, do not take away permissions from a role that would break the operation of the service. Any change of RBAC roles that results in a change of the service behavior is considered a breaking change."
  },
  {
    "reqline": ":white_check_mark: **DO** include error from downstream services as the 'inner-error' section of the response body."
  },
  {
    "reqline": ":white_check_mark: **DO** Enable the customer to provide an ETag to specify a specific version of a file."
  },
  {
    "reqline": ":white_check_mark: **DO** When using a Shared Access Signature (SAS), ensure this is assigned to the container and that the permissions apply to the content as well."
  },
  {
    "reqline": ":white_check_mark: **DO** When using managed identity, ensure the customer has given the proper permissions to access the file container to the service."
  },
  {
    "reqline": ":white_check_mark: **DO** include a JSON object that has string values for \"location\" and \"delimiter.\""
  },
  {
    "reqline": ":white_check_mark: **DO** use a URL to a blob prefix with a container scoped SAS on the end with a minimum of `listing` and `read` permissions."
  },
  {
    "reqline": ":white_check_mark: **DO** use a URL to a blob prefix with a container scoped SAS on the end with a minimum of `write` permissions"
  },
  {
    "reqline": ":white_check_mark: **DO** adhere to the following table for guidance:"
  },
  {
    "reqline": ":white_check_mark: **DO** adhere to the following table for guidance:"
  },
  {
    "reqline": ":white_check_mark: **DO** follow the Azure SDK client guidelines for supporting telemetry headers and Open Telemetry."
  },
  {
    "reqline": ":no_entry: **DO NOT** reject a call if you have custom headers you don't understand, and specifically, distributed tracing headers.",
    "liveTest": true
  }
]